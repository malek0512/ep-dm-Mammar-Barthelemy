---
title: "DM évaluation de performance"
author: "Mammar & Barthelemy"
date: "Saturday, February 28, 2015"
output: html_document
---

L'objectif de ce DM est d'analyser l'importance de la distribution du temps de service sur le temps de réponse dans une file d'attente M/GI/1 avec un ordonnancement LIFO. 
Le processus d'arrivée est un processus de Poisson de taux \lambda (débit)
Les clients ont un temps de service de moyenne 1 pris comme unité de temps de référence.


Simulation de la file LIFO :

```{r}
set.seed(10)
library(plyr)
library(ggplot2)

Service <- function(n=1,typeservice,x,y) {
# genere un temps de service
  switch(typeservice,
         det = rep(1,n),
         uni = runif(n,x,y),
         gamma = rgamma(n,shape=x,scale=y),
         exp = rexp(n,x)
         )
}

FileLIFO <- function(n,lambda,typeservice,x,y,policy) {
    # simulates a M/GI/1 LIFO queue with different preemption policy
    # parameters:
    #    n :  total number of jobs
    #    lambda : arrival rate
    #    typeservice : service law (det uni gamma exp)
    #    x ,y : parameters of the service law
    #    policy: npmtn, pmtn, pmtn_restart, pmtn_reset
    # return value:
    #    vector with response time of each task assuming the queue is initially empty
    
    A <- rexp(n,lambda)         # inter arrival
    t1 <- cumsum(A)             # arrival dates
    t2 <- rep(NA,n)             # completion dates
    S <- Service(n,typeservice,x,y) # initial service times
    
    #### Variables that define the state of the queue
    t = 0               # current time
    remaining = rep(NA,n)  # how much work remains to do for each task
    running = NA        # index of the currently running task
    waiting = c()       # stack with tasks which have arrived and have not been completed yet
    next_arrival = 1    # index of the next task to arrive
    sys_vide = 1        # by curiosity let count the number of times the system is empty
    
    #### A few useful local functions 
    run_task = function() { # runs the last task of the waiting list
      #if there is still a process in the stack to run, we take the last one in
      if(length(waiting)>0) {
        running <<- waiting[length(waiting)]
        #we update the remaning time : it depends on the policy chosen
        remaining[running] <<- switch(policy,
                                      #the process restart from the beginning
                                      npmtn = S[running],
                                      
                                      #At first loop it takes S[running], but after remaining[running] is returned
                                      pmtn = min(S[running],remaining[running],na.rm=T),
                                      
                                      #the process restart from the beginning
                                      pmtn_restart = S[running],
                                      
                                      #the process restart with a shorter time
                                      pmtn_reset = Service(1,typeservice,x,y)
                                      )
        waiting <<- waiting[-length(waiting)] #renvoie le tableau privé de l'element a la position length(waiting) => le dernier element empilé
      }
    }

    push_task = function() { # insert the next_arrival-th task to the waiting list
                             # and run it if there is preemption
      if(policy != "npmtn") {
        if(!is.na(running)) {waiting <<- c(waiting,running)}
        running <<- NA
      }
      waiting <<- c(waiting,next_arrival)
      next_arrival <<- next_arrival+1 
      if(is.na(running)) { run_task() }
    }

    #### Main simulation loop
    while(TRUE) { 
      #dt is the time we will minus the remaning running process time
      # Look for next event
      dt = NA
      #have we reached the number max of process arrival ?
      if(next_arrival <=n) { dt = min(dt ,(t1[next_arrival]-t), na.rm=T ) } #dt=t1[..]-t it's a bit akward to take the min with dt because NA are deleted. Notice that t1[next_arrival]-t=dt is the next process arrival time - current time. So this is the elapsed time
      
      #is some process running ? if so, dt = ramining(running) in case the running process ends before the next process
      if(!is.na(running))  { dt = min(dt,remaining[running], na.rm=T) }
      
      #we've reached the max of process (no next arrival) and no process is running, we take off
      if(is.na(dt)) { break }
      
      # Update state
      t=t+dt
      if(!is.na(running)) {
        remaining[running] = remaining[running] - dt
        if(remaining[running]<=0) {
          t2[running] = t
          running = NA
          
          #it begins to run or rerun or resume the process, and affect remain[running] to the corresponding time service
          run_task()
        }
      }
      if((next_arrival<=n) & (t==t1[next_arrival])) {
        push_task() #insert the next_arrival-th task to the waiting list and run it if there is preemption
      }
      
    }
    
    #count the nnumer of time the system is empty
    for(i in 1:n) {
      if ( t1[i]>t2[i]) {
        sys_vide = sys_vide + 1
      }
    }
    
    list (jobs = data.frame(arrival = t1, completion=t2, service=t2-t1, theoricService=S),
#          events = data.frame(date=date,count=count),
#          workevolution = data.frame(date=datework,work=work),
          sys_vide = sys_vide)
    
}    

```

**Question 1**

Nature des lois de service : 
Illustrons les differences de natures entre les différentes lois de temps de service : 

Les lois deterministe et uniforme sont trivials, si ce n'est qu'on peut ajouté que (dans le cas uniforme) les temps sont compris entre 0 et 10 par choix.

Loi exponentielle : 

La plus part des temps de service sont très court (voire proche de zero) et d'autre (un nombre limité) assez long : c'est typique de la distribution exponentielle.

Loi gamma : 

Nous avons choisi un coefficient x=9 afin de s'éloigner de la loi exponentielle (avec x=1) et densité en forme de cloche.
Comme on peut le voir les temps de service sont $\gt$ 2.5 s


```{r}
set.seed(10)


gamma = data.frame(value=Service(n=100, typeservice="gamma", x=9, y=0.5))
gamma$id  = 1:length(gamma$value)

unif  = data.frame(value=Service(n=100, typeservice="uni", x=1, y=10))
unif$id  = 1:length(unif$value)

det   = data.frame(value=Service(n=100, typeservice="det"))
det$id  = 1:length(det$value)

exp     = data.frame(value=Service(n=100, typeservice="exp", x=1))
exp$id  = 1:length(exp$value)


pdet = ggplot(data=det, aes(x=id, y=value)) + 
  geom_bar(data=det,stat="identity", position="identity") + 
  ylab("Time") + xlab("Client") + 
  ggtitle("Temps de service : loi constante")

punif = ggplot(data=unif, aes(x=id, y=value)) + 
  geom_bar(data=unif,stat="identity", position="identity") + 
  ylab("Time") + xlab("Client") + 
  ggtitle("Temps de service : loi uniforme")

pgamma = ggplot(data=gamma, aes(x=id, y=value)) + 
  geom_bar(data=gamma,stat="identity", position="identity") + 
  ylab("Time") + xlab("Client") + 
  ggtitle("Temps de service : loi gamma")

pexp = ggplot(data=exp, aes(x=id, y=value)) + 
  geom_bar(data=exp,stat="identity", position="identity") + 
  ylab("Time") + xlab("Client") + 
  ggtitle("Temps de service : loi exponentielle")

pdet
punif
pgamma
pexp

```

**Question 2**  -  *Etudions la file M/M/1 - LIFO*
